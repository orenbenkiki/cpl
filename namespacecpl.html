<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CPL: cpl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CPL
   &#160;<span id="projectnumber">0.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cpl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Clever Protection Library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpl_1_1no__delete.html">no_delete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Deleter</code> that doesn't delete the object.  <a href="structcpl_1_1no__delete.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1is.html">is</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder of some value.  <a href="classcpl_1_1is.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1opt.html">opt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder of some optional value.  <a href="classcpl_1_1opt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1shared.html">shared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An indirection that uses reference counting.  <a href="classcpl_1_1shared.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1sptr.html">sptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer that uses reference counting.  <a href="classcpl_1_1sptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1sref.html">sref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference that uses reference counting.  <a href="classcpl_1_1sref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpl_1_1wptr.html">wptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A weak way to obtain a shared pointer.  <a href="structcpl_1_1wptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1unique.html">unique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An indirection that deletes the data when it is deleted.  <a href="classcpl_1_1unique.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1uptr.html">uptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer that deletes the data when it is deleted.  <a href="classcpl_1_1uptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1uref.html">uref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference that deletes the data when it is deleted.  <a href="classcpl_1_1uref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1borrow.html">borrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An indirection for data whose lifetime is determined elsewhere.  <a href="classcpl_1_1borrow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1ptr.html">ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer for data whose lifetime is determined elsewhere.  <a href="classcpl_1_1ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1ref.html">ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference for data whose lifetime is determined elsewhere.  <a href="classcpl_1_1ref.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1bitset.html">bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size vector of bits.  <a href="classcpl_1_1bitset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1map.html">map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from keys to values.  <a href="classcpl_1_1map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1set.html">set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of values.  <a href="classcpl_1_1set.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1string.html">string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just a string.  <a href="classcpl_1_1string.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpl_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic vector of values.  <a href="classcpl_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5a0b6e849e915ae912616e8beb9953bc"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::experimental::in_place_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a5a0b6e849e915ae912616e8beb9953bc">in_place_t</a></td></tr>
<tr class="memdesc:a5a0b6e849e915ae912616e8beb9953bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow convenient access to <code>std::experimental::in_place_t</code>.  <a href="#a5a0b6e849e915ae912616e8beb9953bc"></a><br/></td></tr>
<tr class="separator:a5a0b6e849e915ae912616e8beb9953bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3414592c64c7ef9b526d740c7cf435bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">unsafe_raw_t</a> </td></tr>
<tr class="memdesc:a3414592c64c7ef9b526d740c7cf435bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additional parameter for unsafe raw pointer operations.  <a href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">More...</a><br/></td></tr>
<tr class="separator:a3414592c64c7ef9b526d740c7cf435bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ddc9416cbac9cf7f5f665714489da1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">unsafe_static_t</a> </td></tr>
<tr class="memdesc:ab9ddc9416cbac9cf7f5f665714489da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additional parameter for unsafe static cast operations.  <a href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">More...</a><br/></td></tr>
<tr class="separator:ab9ddc9416cbac9cf7f5f665714489da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968cd2eed2b384295813a70b4c835b0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">unsafe_dynamic_t</a> </td></tr>
<tr class="memdesc:a968cd2eed2b384295813a70b4c835b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additional parameter for unsafe dynamic cast operations.  <a href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">More...</a><br/></td></tr>
<tr class="separator:a968cd2eed2b384295813a70b4c835b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361f47273a7617ebea123aa175c65486"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">unsafe_const_t</a> </td></tr>
<tr class="memdesc:a361f47273a7617ebea123aa175c65486"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additional parameter for unsafe const cast operations.  <a href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">More...</a><br/></td></tr>
<tr class="separator:a361f47273a7617ebea123aa175c65486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac642594daa02bd36f81c2da3d6b09c6d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac642594daa02bd36f81c2da3d6b09c6d"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ac642594daa02bd36f81c2da3d6b09c6d">cast_raw_ptr</a> (U *other, <a class="el" href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">unsafe_raw_t</a>)</td></tr>
<tr class="memdesc:ac642594daa02bd36f81c2da3d6b09c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a raw pointer to a different type.  <a href="#ac642594daa02bd36f81c2da3d6b09c6d"></a><br/></td></tr>
<tr class="separator:ac642594daa02bd36f81c2da3d6b09c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5496e4928308f2ce409e12fe33df1f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aaa5496e4928308f2ce409e12fe33df1f"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#aaa5496e4928308f2ce409e12fe33df1f">cast_raw_ptr</a> (U *other, <a class="el" href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">unsafe_static_t</a>)</td></tr>
<tr class="memdesc:aaa5496e4928308f2ce409e12fe33df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a raw pointer to a different type.  <a href="#aaa5496e4928308f2ce409e12fe33df1f"></a><br/></td></tr>
<tr class="separator:aaa5496e4928308f2ce409e12fe33df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee03dd5b8a4973624221d9135833c7f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aee03dd5b8a4973624221d9135833c7f8"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#aee03dd5b8a4973624221d9135833c7f8">cast_raw_ptr</a> (U *other, <a class="el" href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">unsafe_dynamic_t</a>)</td></tr>
<tr class="memdesc:aee03dd5b8a4973624221d9135833c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a raw pointer to a different type.  <a href="#aee03dd5b8a4973624221d9135833c7f8"></a><br/></td></tr>
<tr class="separator:aee03dd5b8a4973624221d9135833c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eccb73ec89685c6e8cea1778cea2b42"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7eccb73ec89685c6e8cea1778cea2b42"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a7eccb73ec89685c6e8cea1778cea2b42">cast_raw_ptr</a> (U *other, <a class="el" href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">unsafe_const_t</a>)</td></tr>
<tr class="memdesc:a7eccb73ec89685c6e8cea1778cea2b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a raw pointer to a different type.  <a href="#a7eccb73ec89685c6e8cea1778cea2b42"></a><br/></td></tr>
<tr class="separator:a7eccb73ec89685c6e8cea1778cea2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797c2f74054e26009863e31dce06e924"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a797c2f74054e26009863e31dce06e924"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a797c2f74054e26009863e31dce06e924">cast_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other, <a class="el" href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">unsafe_raw_t</a>)</td></tr>
<tr class="memdesc:a797c2f74054e26009863e31dce06e924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a unique pointer to a different type.  <a href="#a797c2f74054e26009863e31dce06e924"></a><br/></td></tr>
<tr class="separator:a797c2f74054e26009863e31dce06e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32966b9f4abeb6d91bbef1a084ecc516"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a32966b9f4abeb6d91bbef1a084ecc516"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a32966b9f4abeb6d91bbef1a084ecc516">cast_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other, <a class="el" href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">unsafe_static_t</a>)</td></tr>
<tr class="memdesc:a32966b9f4abeb6d91bbef1a084ecc516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a unique pointer to a different type.  <a href="#a32966b9f4abeb6d91bbef1a084ecc516"></a><br/></td></tr>
<tr class="separator:a32966b9f4abeb6d91bbef1a084ecc516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca09643594d6dd94536695f7a3d13c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a11ca09643594d6dd94536695f7a3d13c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a11ca09643594d6dd94536695f7a3d13c">cast_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other, <a class="el" href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">unsafe_dynamic_t</a>)</td></tr>
<tr class="memdesc:a11ca09643594d6dd94536695f7a3d13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a unique pointer to a different type.  <a href="#a11ca09643594d6dd94536695f7a3d13c"></a><br/></td></tr>
<tr class="separator:a11ca09643594d6dd94536695f7a3d13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544dc4ee100e36788220788b86927c6f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a544dc4ee100e36788220788b86927c6f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a544dc4ee100e36788220788b86927c6f">cast_unique_ptr</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other, <a class="el" href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">unsafe_const_t</a>)</td></tr>
<tr class="memdesc:a544dc4ee100e36788220788b86927c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a unique pointer to a different type.  <a href="#a544dc4ee100e36788220788b86927c6f"></a><br/></td></tr>
<tr class="separator:a544dc4ee100e36788220788b86927c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b94622c80062ffab3f275fd9f78ae71"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7b94622c80062ffab3f275fd9f78ae71"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a7b94622c80062ffab3f275fd9f78ae71">cast_shared_ptr</a> (const std::shared_ptr&lt; U &gt; &amp;other, <a class="el" href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">unsafe_raw_t</a>)</td></tr>
<tr class="memdesc:a7b94622c80062ffab3f275fd9f78ae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a shared pointer to a different type.  <a href="#a7b94622c80062ffab3f275fd9f78ae71"></a><br/></td></tr>
<tr class="separator:a7b94622c80062ffab3f275fd9f78ae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040ae2d0120b81fb1166bcc6846348b8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a040ae2d0120b81fb1166bcc6846348b8"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a040ae2d0120b81fb1166bcc6846348b8">cast_shared_ptr</a> (const std::shared_ptr&lt; U &gt; &amp;other, <a class="el" href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">unsafe_static_t</a>)</td></tr>
<tr class="memdesc:a040ae2d0120b81fb1166bcc6846348b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a shared pointer to a different type.  <a href="#a040ae2d0120b81fb1166bcc6846348b8"></a><br/></td></tr>
<tr class="separator:a040ae2d0120b81fb1166bcc6846348b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788903c23291104e3697939658db3e8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a788903c23291104e3697939658db3e8d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a788903c23291104e3697939658db3e8d">cast_shared_ptr</a> (const std::shared_ptr&lt; U &gt; &amp;other, <a class="el" href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">unsafe_dynamic_t</a>)</td></tr>
<tr class="memdesc:a788903c23291104e3697939658db3e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a shared pointer to a different type.  <a href="#a788903c23291104e3697939658db3e8d"></a><br/></td></tr>
<tr class="separator:a788903c23291104e3697939658db3e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c692380f478a93f3cacf6a749cabc63"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8c692380f478a93f3cacf6a749cabc63"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a8c692380f478a93f3cacf6a749cabc63">cast_shared_ptr</a> (const std::shared_ptr&lt; U &gt; &amp;other, <a class="el" href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">unsafe_const_t</a>)</td></tr>
<tr class="memdesc:a8c692380f478a93f3cacf6a749cabc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a shared pointer to a different type.  <a href="#a8c692380f478a93f3cacf6a749cabc63"></a><br/></td></tr>
<tr class="separator:a8c692380f478a93f3cacf6a749cabc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6093b05e30e21c22341a588f2f3c317d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename C &gt; </td></tr>
<tr class="memitem:a6093b05e30e21c22341a588f2f3c317d"><td class="memTemplItemLeft" align="right" valign="top">std::weak_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a6093b05e30e21c22341a588f2f3c317d">cast_weak_ptr</a> (const std::shared_ptr&lt; T &gt; &amp;into_unsafe_ptr, const std::weak_ptr&lt; U &gt; &amp;from_weak_ptr, C cast_type)</td></tr>
<tr class="memdesc:a6093b05e30e21c22341a588f2f3c317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the weak pointer of a <code>ptr</code> of a different type.  <a href="#a6093b05e30e21c22341a588f2f3c317d"></a><br/></td></tr>
<tr class="separator:a6093b05e30e21c22341a588f2f3c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69747258a545d1281eb66827c56c3dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa69747258a545d1281eb66827c56c3dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#aa69747258a545d1281eb66827c56c3dc">make_sref</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa69747258a545d1281eb66827c56c3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create some value owned by a shared reference.  <a href="#aa69747258a545d1281eb66827c56c3dc"></a><br/></td></tr>
<tr class="separator:aa69747258a545d1281eb66827c56c3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c4ee3440a6b4367b11075c4413718f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a03c4ee3440a6b4367b11075c4413718f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a03c4ee3440a6b4367b11075c4413718f">make_sptr</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a03c4ee3440a6b4367b11075c4413718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create some value owned by a shared pointer.  <a href="#a03c4ee3440a6b4367b11075c4413718f"></a><br/></td></tr>
<tr class="separator:a03c4ee3440a6b4367b11075c4413718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8cb4c0096c46fef78b5f07f15f4008"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a3c8cb4c0096c46fef78b5f07f15f4008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a3c8cb4c0096c46fef78b5f07f15f4008">make_uref</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3c8cb4c0096c46fef78b5f07f15f4008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create some value owned by a unique reference.  <a href="#a3c8cb4c0096c46fef78b5f07f15f4008"></a><br/></td></tr>
<tr class="separator:a3c8cb4c0096c46fef78b5f07f15f4008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4fac44bb6dbf5d9bb28c3d17983c86"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:adf4fac44bb6dbf5d9bb28c3d17983c86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#adf4fac44bb6dbf5d9bb28c3d17983c86">make_uptr</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:adf4fac44bb6dbf5d9bb28c3d17983c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create some value owned by a unique pointer.  <a href="#adf4fac44bb6dbf5d9bb28c3d17983c86"></a><br/></td></tr>
<tr class="separator:adf4fac44bb6dbf5d9bb28c3d17983c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205c84d0c8d8291953c58fa3a9f7a0df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a205c84d0c8d8291953c58fa3a9f7a0df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a205c84d0c8d8291953c58fa3a9f7a0df">unsafe_ref</a> (T &amp;data)</td></tr>
<tr class="memdesc:a205c84d0c8d8291953c58fa3a9f7a0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unsafe reference to raw data.  <a href="#a205c84d0c8d8291953c58fa3a9f7a0df"></a><br/></td></tr>
<tr class="separator:a205c84d0c8d8291953c58fa3a9f7a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16040ea171333091ba0a85d5bd0064"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e16040ea171333091ba0a85d5bd0064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a0e16040ea171333091ba0a85d5bd0064">unsafe_ptr</a> (T &amp;data)</td></tr>
<tr class="memdesc:a0e16040ea171333091ba0a85d5bd0064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unsafe pointer to raw data.  <a href="#a0e16040ea171333091ba0a85d5bd0064"></a><br/></td></tr>
<tr class="separator:a0e16040ea171333091ba0a85d5bd0064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeb03a3385c66011c8699ffd001d5db"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9aeb03a3385c66011c8699ffd001d5db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a9aeb03a3385c66011c8699ffd001d5db">cast_clever</a> (const <a class="el" href="classcpl_1_1sref.html">sref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a9aeb03a3385c66011c8699ffd001d5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between reference types.  <a href="#a9aeb03a3385c66011c8699ffd001d5db"></a><br/></td></tr>
<tr class="separator:a9aeb03a3385c66011c8699ffd001d5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cbc0df9eac079969ed863e7a5c5866"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a38cbc0df9eac079969ed863e7a5c5866"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a38cbc0df9eac079969ed863e7a5c5866">cast_clever</a> (const <a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a38cbc0df9eac079969ed863e7a5c5866"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between pointer types.  <a href="#a38cbc0df9eac079969ed863e7a5c5866"></a><br/></td></tr>
<tr class="separator:a38cbc0df9eac079969ed863e7a5c5866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fcd2fea50df5adaf3c8210249317bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab7fcd2fea50df5adaf3c8210249317bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ab7fcd2fea50df5adaf3c8210249317bb">cast_clever</a> (const <a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:ab7fcd2fea50df5adaf3c8210249317bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between pointer types.  <a href="#ab7fcd2fea50df5adaf3c8210249317bb"></a><br/></td></tr>
<tr class="separator:ab7fcd2fea50df5adaf3c8210249317bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811acc150b293d6aa0ba696ab85fa1c0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a811acc150b293d6aa0ba696ab85fa1c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a811acc150b293d6aa0ba696ab85fa1c0">cast_clever</a> (<a class="el" href="classcpl_1_1uref.html">uref</a>&lt; U &gt; &amp;&amp;from_ref)</td></tr>
<tr class="memdesc:a811acc150b293d6aa0ba696ab85fa1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between reference types.  <a href="#a811acc150b293d6aa0ba696ab85fa1c0"></a><br/></td></tr>
<tr class="separator:a811acc150b293d6aa0ba696ab85fa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2f18b2919ce81361036c36f0ac6991"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0f2f18b2919ce81361036c36f0ac6991"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a0f2f18b2919ce81361036c36f0ac6991">cast_clever</a> (<a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; U &gt; &amp;&amp;from_ptr)</td></tr>
<tr class="memdesc:a0f2f18b2919ce81361036c36f0ac6991"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between pointer types.  <a href="#a0f2f18b2919ce81361036c36f0ac6991"></a><br/></td></tr>
<tr class="separator:a0f2f18b2919ce81361036c36f0ac6991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bdcbbbbba04762582417b022b92d7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab1bdcbbbbba04762582417b022b92d7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ab1bdcbbbbba04762582417b022b92d7f">cast_clever</a> (const <a class="el" href="classcpl_1_1ref.html">ref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:ab1bdcbbbbba04762582417b022b92d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between reference types.  <a href="#ab1bdcbbbbba04762582417b022b92d7f"></a><br/></td></tr>
<tr class="separator:ab1bdcbbbbba04762582417b022b92d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3db3c0707b3355715484b6069d9f71"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a2e3db3c0707b3355715484b6069d9f71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a2e3db3c0707b3355715484b6069d9f71">cast_clever</a> (const <a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a2e3db3c0707b3355715484b6069d9f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clever cast between pointer types.  <a href="#a2e3db3c0707b3355715484b6069d9f71"></a><br/></td></tr>
<tr class="separator:a2e3db3c0707b3355715484b6069d9f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081bdf2cd9349c9ff69c3e46109702d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a081bdf2cd9349c9ff69c3e46109702d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a081bdf2cd9349c9ff69c3e46109702d8">cast_reinterpret</a> (const <a class="el" href="classcpl_1_1sref.html">sref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a081bdf2cd9349c9ff69c3e46109702d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between reference types.  <a href="#a081bdf2cd9349c9ff69c3e46109702d8"></a><br/></td></tr>
<tr class="separator:a081bdf2cd9349c9ff69c3e46109702d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a4dcef08c1023653704fed971f4c11"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac7a4dcef08c1023653704fed971f4c11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ac7a4dcef08c1023653704fed971f4c11">cast_reinterpret</a> (const <a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:ac7a4dcef08c1023653704fed971f4c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between pointer types.  <a href="#ac7a4dcef08c1023653704fed971f4c11"></a><br/></td></tr>
<tr class="separator:ac7a4dcef08c1023653704fed971f4c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbfe4e8384a8458f95329b13a2d6670"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3cbfe4e8384a8458f95329b13a2d6670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a3cbfe4e8384a8458f95329b13a2d6670">cast_reinterpret</a> (const <a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a3cbfe4e8384a8458f95329b13a2d6670"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between pointer types.  <a href="#a3cbfe4e8384a8458f95329b13a2d6670"></a><br/></td></tr>
<tr class="separator:a3cbfe4e8384a8458f95329b13a2d6670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4efd5be5daaf6ce4cecb4cff55a5308"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad4efd5be5daaf6ce4cecb4cff55a5308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ad4efd5be5daaf6ce4cecb4cff55a5308">cast_reinterpret</a> (<a class="el" href="classcpl_1_1uref.html">uref</a>&lt; U &gt; &amp;&amp;from_ref)</td></tr>
<tr class="memdesc:ad4efd5be5daaf6ce4cecb4cff55a5308"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between reference types.  <a href="#ad4efd5be5daaf6ce4cecb4cff55a5308"></a><br/></td></tr>
<tr class="separator:ad4efd5be5daaf6ce4cecb4cff55a5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ab491d47fc4401b7ff3b7051fd554f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af4ab491d47fc4401b7ff3b7051fd554f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#af4ab491d47fc4401b7ff3b7051fd554f">cast_reinterpret</a> (<a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; U &gt; &amp;&amp;from_ptr)</td></tr>
<tr class="memdesc:af4ab491d47fc4401b7ff3b7051fd554f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between pointer types.  <a href="#af4ab491d47fc4401b7ff3b7051fd554f"></a><br/></td></tr>
<tr class="separator:af4ab491d47fc4401b7ff3b7051fd554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7202df77cf98c87206999239ca984e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3c7202df77cf98c87206999239ca984e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a3c7202df77cf98c87206999239ca984e">cast_reinterpret</a> (const <a class="el" href="classcpl_1_1ref.html">ref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a3c7202df77cf98c87206999239ca984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between reference types.  <a href="#a3c7202df77cf98c87206999239ca984e"></a><br/></td></tr>
<tr class="separator:a3c7202df77cf98c87206999239ca984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8991d28822179e536ab745a93daa48cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8991d28822179e536ab745a93daa48cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a8991d28822179e536ab745a93daa48cc">cast_reinterpret</a> (const <a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a8991d28822179e536ab745a93daa48cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret cast between pointer types.  <a href="#a8991d28822179e536ab745a93daa48cc"></a><br/></td></tr>
<tr class="separator:a8991d28822179e536ab745a93daa48cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332fd4d2b5d4d5123c3a5c3fb67efddf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a332fd4d2b5d4d5123c3a5c3fb67efddf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a332fd4d2b5d4d5123c3a5c3fb67efddf">cast_dynamic</a> (const <a class="el" href="classcpl_1_1sref.html">sref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a332fd4d2b5d4d5123c3a5c3fb67efddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between reference types.  <a href="#a332fd4d2b5d4d5123c3a5c3fb67efddf"></a><br/></td></tr>
<tr class="separator:a332fd4d2b5d4d5123c3a5c3fb67efddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799206e33be9e2cb9ea99d65d661914b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a799206e33be9e2cb9ea99d65d661914b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a799206e33be9e2cb9ea99d65d661914b">cast_dynamic</a> (const <a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a799206e33be9e2cb9ea99d65d661914b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between pointer types.  <a href="#a799206e33be9e2cb9ea99d65d661914b"></a><br/></td></tr>
<tr class="separator:a799206e33be9e2cb9ea99d65d661914b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e18f77c73d40d474a86abcc9ec6b320"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7e18f77c73d40d474a86abcc9ec6b320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a7e18f77c73d40d474a86abcc9ec6b320">cast_dynamic</a> (const <a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a7e18f77c73d40d474a86abcc9ec6b320"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between pointer types.  <a href="#a7e18f77c73d40d474a86abcc9ec6b320"></a><br/></td></tr>
<tr class="separator:a7e18f77c73d40d474a86abcc9ec6b320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec1bb714ed38157e82f5f5dd0632f26"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afec1bb714ed38157e82f5f5dd0632f26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#afec1bb714ed38157e82f5f5dd0632f26">cast_dynamic</a> (<a class="el" href="classcpl_1_1uref.html">uref</a>&lt; U &gt; &amp;&amp;from_ref)</td></tr>
<tr class="memdesc:afec1bb714ed38157e82f5f5dd0632f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between reference types.  <a href="#afec1bb714ed38157e82f5f5dd0632f26"></a><br/></td></tr>
<tr class="separator:afec1bb714ed38157e82f5f5dd0632f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64faadd3645eaa26a54955966fe87bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa64faadd3645eaa26a54955966fe87bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#aa64faadd3645eaa26a54955966fe87bc">cast_dynamic</a> (<a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; U &gt; &amp;&amp;from_ptr)</td></tr>
<tr class="memdesc:aa64faadd3645eaa26a54955966fe87bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between pointer types.  <a href="#aa64faadd3645eaa26a54955966fe87bc"></a><br/></td></tr>
<tr class="separator:aa64faadd3645eaa26a54955966fe87bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa59e660f7aa3b8e1021f27e80f94b20"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afa59e660f7aa3b8e1021f27e80f94b20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#afa59e660f7aa3b8e1021f27e80f94b20">cast_dynamic</a> (const <a class="el" href="classcpl_1_1ref.html">ref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:afa59e660f7aa3b8e1021f27e80f94b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between reference types.  <a href="#afa59e660f7aa3b8e1021f27e80f94b20"></a><br/></td></tr>
<tr class="separator:afa59e660f7aa3b8e1021f27e80f94b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e053a3fa5df58e98968757d84e632f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a39e053a3fa5df58e98968757d84e632f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a39e053a3fa5df58e98968757d84e632f">cast_dynamic</a> (const <a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a39e053a3fa5df58e98968757d84e632f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic cast between pointer types.  <a href="#a39e053a3fa5df58e98968757d84e632f"></a><br/></td></tr>
<tr class="separator:a39e053a3fa5df58e98968757d84e632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b200c580762bcd748c55f80d3f63ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a70b200c580762bcd748c55f80d3f63ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a70b200c580762bcd748c55f80d3f63ee">cast_static</a> (const <a class="el" href="classcpl_1_1sref.html">sref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a70b200c580762bcd748c55f80d3f63ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between reference types.  <a href="#a70b200c580762bcd748c55f80d3f63ee"></a><br/></td></tr>
<tr class="separator:a70b200c580762bcd748c55f80d3f63ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21269317666734af32412d9dbacb3cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad21269317666734af32412d9dbacb3cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ad21269317666734af32412d9dbacb3cb">cast_static</a> (const <a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:ad21269317666734af32412d9dbacb3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between pointer types.  <a href="#ad21269317666734af32412d9dbacb3cb"></a><br/></td></tr>
<tr class="separator:ad21269317666734af32412d9dbacb3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc96be13e230e45db5ce3de83b9da76e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afc96be13e230e45db5ce3de83b9da76e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#afc96be13e230e45db5ce3de83b9da76e">cast_static</a> (const <a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:afc96be13e230e45db5ce3de83b9da76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between pointer types.  <a href="#afc96be13e230e45db5ce3de83b9da76e"></a><br/></td></tr>
<tr class="separator:afc96be13e230e45db5ce3de83b9da76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace6049e216b9adf437158c8fb34a7be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aace6049e216b9adf437158c8fb34a7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#aace6049e216b9adf437158c8fb34a7be">cast_static</a> (<a class="el" href="classcpl_1_1uref.html">uref</a>&lt; U &gt; &amp;&amp;from_ref)</td></tr>
<tr class="memdesc:aace6049e216b9adf437158c8fb34a7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between reference types.  <a href="#aace6049e216b9adf437158c8fb34a7be"></a><br/></td></tr>
<tr class="separator:aace6049e216b9adf437158c8fb34a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c32059b0c16ac165dddcefac63d17f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4c32059b0c16ac165dddcefac63d17f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a4c32059b0c16ac165dddcefac63d17f3">cast_static</a> (<a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; U &gt; &amp;&amp;from_ptr)</td></tr>
<tr class="memdesc:a4c32059b0c16ac165dddcefac63d17f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between pointer types.  <a href="#a4c32059b0c16ac165dddcefac63d17f3"></a><br/></td></tr>
<tr class="separator:a4c32059b0c16ac165dddcefac63d17f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad699e8a81ec43e4ce8c69b3096e653b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad699e8a81ec43e4ce8c69b3096e653b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ad699e8a81ec43e4ce8c69b3096e653b9">cast_static</a> (const <a class="el" href="classcpl_1_1ref.html">ref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:ad699e8a81ec43e4ce8c69b3096e653b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between reference types.  <a href="#ad699e8a81ec43e4ce8c69b3096e653b9"></a><br/></td></tr>
<tr class="separator:ad699e8a81ec43e4ce8c69b3096e653b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5a3a672ff39f9c8a574372dba2c26b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0e5a3a672ff39f9c8a574372dba2c26b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a0e5a3a672ff39f9c8a574372dba2c26b">cast_static</a> (const <a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a0e5a3a672ff39f9c8a574372dba2c26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static cast between pointer types.  <a href="#a0e5a3a672ff39f9c8a574372dba2c26b"></a><br/></td></tr>
<tr class="separator:a0e5a3a672ff39f9c8a574372dba2c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ae86127a5b3b4f18c69a60f6a1c21"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ab61ae86127a5b3b4f18c69a60f6a1c21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ab61ae86127a5b3b4f18c69a60f6a1c21">cast_const</a> (const <a class="el" href="classcpl_1_1sref.html">sref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:ab61ae86127a5b3b4f18c69a60f6a1c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between reference types.  <a href="#ab61ae86127a5b3b4f18c69a60f6a1c21"></a><br/></td></tr>
<tr class="separator:ab61ae86127a5b3b4f18c69a60f6a1c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225b146ef3c837a9748e43b1c6b0ad20"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a225b146ef3c837a9748e43b1c6b0ad20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a225b146ef3c837a9748e43b1c6b0ad20">cast_const</a> (const <a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a225b146ef3c837a9748e43b1c6b0ad20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between pointer types.  <a href="#a225b146ef3c837a9748e43b1c6b0ad20"></a><br/></td></tr>
<tr class="separator:a225b146ef3c837a9748e43b1c6b0ad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbabc449527c16a2632f253df5e09a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6cbabc449527c16a2632f253df5e09a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a6cbabc449527c16a2632f253df5e09a5">cast_const</a> (const <a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a6cbabc449527c16a2632f253df5e09a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between pointer types.  <a href="#a6cbabc449527c16a2632f253df5e09a5"></a><br/></td></tr>
<tr class="separator:a6cbabc449527c16a2632f253df5e09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063ecffdb1034d42d2dd071110dbec8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8063ecffdb1034d42d2dd071110dbec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a8063ecffdb1034d42d2dd071110dbec8">cast_const</a> (<a class="el" href="classcpl_1_1uref.html">uref</a>&lt; U &gt; &amp;&amp;from_ref)</td></tr>
<tr class="memdesc:a8063ecffdb1034d42d2dd071110dbec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between reference types.  <a href="#a8063ecffdb1034d42d2dd071110dbec8"></a><br/></td></tr>
<tr class="separator:a8063ecffdb1034d42d2dd071110dbec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd556840d0daa32a968229b8dc500619"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afd556840d0daa32a968229b8dc500619"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#afd556840d0daa32a968229b8dc500619">cast_const</a> (<a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt; U &gt; &amp;&amp;from_ptr)</td></tr>
<tr class="memdesc:afd556840d0daa32a968229b8dc500619"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between pointer types.  <a href="#afd556840d0daa32a968229b8dc500619"></a><br/></td></tr>
<tr class="separator:afd556840d0daa32a968229b8dc500619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df17a8a23834d5c757305de6e0be3c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a3df17a8a23834d5c757305de6e0be3c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a3df17a8a23834d5c757305de6e0be3c7">cast_const</a> (const <a class="el" href="classcpl_1_1ref.html">ref</a>&lt; U &gt; &amp;from_ref)</td></tr>
<tr class="memdesc:a3df17a8a23834d5c757305de6e0be3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between reference types.  <a href="#a3df17a8a23834d5c757305de6e0be3c7"></a><br/></td></tr>
<tr class="separator:a3df17a8a23834d5c757305de6e0be3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fcba4f5ab20f462b81b9223ba731f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a747fcba4f5ab20f462b81b9223ba731f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecpl.html#a747fcba4f5ab20f462b81b9223ba731f">cast_const</a> (const <a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt; U &gt; &amp;from_ptr)</td></tr>
<tr class="memdesc:a747fcba4f5ab20f462b81b9223ba731f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const cast between pointer types.  <a href="#a747fcba4f5ab20f462b81b9223ba731f"></a><br/></td></tr>
<tr class="separator:a747fcba4f5ab20f462b81b9223ba731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad97ed0af4f1706abd58d26e2ccb44fbc"><td class="memItemLeft" align="right" valign="top">constexpr <br class="typebreak"/>
std::experimental::in_place_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecpl.html#ad97ed0af4f1706abd58d26e2ccb44fbc">in_place</a> {}</td></tr>
<tr class="memdesc:ad97ed0af4f1706abd58d26e2ccb44fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow convenient access to <code>std::experimental::in_place</code>.  <a href="#ad97ed0af4f1706abd58d26e2ccb44fbc"></a><br/></td></tr>
<tr class="separator:ad97ed0af4f1706abd58d26e2ccb44fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Clever Protection Library. </p>
<p><em>"Clever people solve problems wise people avoid".</em></p>
<h2>Goals</h2>
<p>CPL tries to achieve the following goals:</p>
<ul>
<li>Efficiency: The program should run at 100% speed without extra overheads.</li>
</ul>
<ul>
<li>Safety: Pointers should always point to valid memory, vector element indices should be within bounds, map keys should exist, there shouldn't be unexpected aliasing or data races, etc.</li>
</ul>
<p>These goals are contradictory. A notable attempt to (partially) simultaneously satisfy both goals is the <a href="http://www.rust-lang.org/">Rust language</a>. Most languages and tools (C, C++, Java, Swift, Go, ...) pick a specific trade-off point (C/C++ focus more on efficiency, Java/Swift/Go focus more on safety).</p>
<p>CPL accepts that there's no way to achieve both goals at once, so it sets out to achieve them one at a time. That is, CPL allows compiling the same C++ source code for two trade-off points: maximal efficiency, and maximal safety.</p>
<p>Defining <a class="el" href="cpl_8hpp.html#a95a76432378249bc382289ec5ee99b78">CPL_FAST</a> compiles into a fast version of the collections and the pointers (which is based on raw pointers). This will provide the maximal execution speed, at the cost of ignoring most lifetime/data race errors.</p>
<p>Defining <a class="el" href="cpl_8hpp.html#a958e4162617815fa1dea559552b223d7">CPL_SAFE</a>, we compile into a safe version of the collections and the pointers (which is based mainly on <code>weak_ptr</code>). This will detect most lifetime/data race errors, at the cost of greatly reduced execution speed (&gt;10x run-time).</p>
<p>This meshes well with the standard practice of generating a debug and a release version of the same library (or program). When the safe variant detects a problem, it invokes <a class="el" href="cpl_8hpp.html#a47acc8f4f3dd8abe73acdf169aea84ce">CPL_ASSERT</a> to indicate the problem. By default this is just a call to <code>assert</code> but you can <code>define</code> it to whatever you want (<code>throw</code>, print a stack trace, etc.).</p>
<p>While this approach is far from perfect, it is lightweight and practical. It also has the benefit of clearly documenting the programmer intent, instead of using raw pointers. Just this benefit is almost worth the hassle of using CPL all on its own.</p>
<h2>Usage</h2>
<p>To use CPL, simply include <code><a class="el" href="cpl_8hpp.html" title="Implement the clever protection library (CPL).">cpl.hpp</a></code> and use the types defined in it.</p>
<h2>Types</h2>
<p>CPL provides the following set of types:</p>
<table class="doxtable">
<tr>
<th>Type </th><th>May be null? </th><th>Data lifetime is as long as </th><th>Fast implementation is based on </th></tr>
<tr>
<td><a class="el" href="classcpl_1_1is.html">cpl::is</a> </td><td>No </td><td>The <code>is</code> exists </td><td><code>T</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1opt.html">cpl::opt</a> </td><td>Yes </td><td>The <code>opt</code> exists and is not reset </td><td><code>std::experimental::optional&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1uref.html">cpl::uref</a> </td><td>No </td><td>The <code>uref</code> exists </td><td><code>std::unique_ptr&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1uptr.html">cpl::uptr</a> </td><td>Yes </td><td>The <code>uptr</code> exists and is not reset </td><td><code>std::unique_ptr&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1sref.html">cpl::sref</a> </td><td>No </td><td>The <code>sref</code> exists </td><td><code>std::shared_ptr&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1sptr.html">cpl::sptr</a> </td><td>Yes </td><td>The <code>sptr</code> exists </td><td><code>std::shared_ptr&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="structcpl_1_1wptr.html">cpl::wptr</a> </td><td>Yes </td><td>Some <code>sptr</code> exists </td><td><code>std::weak_ptr&lt;T&gt;</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1ref.html">cpl::ref</a> </td><td>No </td><td>One of the above holds the data </td><td><code>std::reference_wrapper</code> </td></tr>
<tr>
<td><a class="el" href="classcpl_1_1ptr.html">cpl::ptr</a> </td><td>Yes </td><td>One of the above holds the data </td><td><code>T*</code> </td></tr>
</table>
<h2>Implementation</h2>
<p>The fast implementation has zero cost (assuming optimized compilation). In some cases it is actually faster than the standard implementation (we disable some checks as they will be done in safe mode).</p>
<p>The safe implementation is very slow (&gt;10x slowdown), but is extremely safe and will helpfully report (m)any memory issues in the earliest possible moment. Most of the time it will point directly at the buggy line, making it much easier to debug the code.</p>
<h2>Interface</h2>
<p>The interface of the CPL types is as close as possible to the interface of the types they are based on. Note that the base types have somewhat inconsistent interface; for example, only <code>opt</code> has <code>value_or</code>, and only the <code>const</code>-ness of <code>is</code> and <code>opt</code> is reflected in the accessed value (that is, a <code>const ref&lt;T&gt;</code> is not the same as <code>ref&lt;const T&gt;</code>).</p>
<p>All the pointer-like types provide the usual <code>operator*</code>, <code>operator-&gt;</code> and <code>operator bool</code> operators, and sometimes also well as <code>get</code>, <code>value</code>, and <code>value_or</code> (if these are provided by the relevant standard type, and also a <code>reset()</code> for <a class="el" href="classcpl_1_1opt.html">cpl::opt</a> because it just makes sense).</p>
<p>In addition, <code><a class="el" href="classcpl_1_1ptr.html" title="A pointer for data whose lifetime is determined elsewhere.">cpl::ptr</a></code> provide <code>ref</code> and <code>ref_or</code> methods. These are more efficient than <code>value</code> and <code>value_or</code> since they just return a reference; using CPL types we avoid the reference-to-deleted-temporary-object problem that prevented <code>value_or</code> from returning a reference.</p>
<p>The reference types provide the same interface, minus <code>operator bool</code>, and with the addition of <code>operator T&amp;</code>.</p>
<p>It would have been nice to have a consistent interface for the different types, but it was deemed more important to stay as close as possible to the standard types.</p>
<p>For a semblance of consistency, <a class="el" href="classcpl_1_1ptr.html">cpl::ptr</a> and <a class="el" href="classcpl_1_1ref.html">cpl::ref</a> have a similar interface to <a class="el" href="classcpl_1_1sref.html">cpl::sref</a> and <a class="el" href="classcpl_1_1uref.html">cpl::uref</a>, which are in turn similar to <a class="el" href="classcpl_1_1sptr.html">cpl::sptr</a> and <a class="el" href="classcpl_1_1uptr.html">cpl::uptr</a> - for example, they also provides a <code>get</code>. This means that all the "reference" types, <a class="el" href="classcpl_1_1ref.html">cpl::ref</a> included, are more like a guaranteed-non-null-<code>T*</code> than a <code>T&amp;</code>. This is also reflected in the fact that <code>const</code>-ness of the CPL type does not mean <code>const</code>-ness of the accessed value. It is very difficult to create a "smart
reference" type in C++ as it is at the time of writing this (C++14). At least there's some comfort in knowing that <code>-&gt;</code> will always work to access the data members.</p>
<h2>Casting</h2>
<p>CPL provides <a class="el" href="namespacecpl.html#a70b200c580762bcd748c55f80d3f63ee">cpl::cast_static</a>, <a class="el" href="namespacecpl.html#a332fd4d2b5d4d5123c3a5c3fb67efddf">cpl::cast_dynamic</a>, <a class="el" href="namespacecpl.html#a081bdf2cd9349c9ff69c3e46109702d8">cpl::cast_reinterpret</a> and <a class="el" href="namespacecpl.html#ab61ae86127a5b3b4f18c69a60f6a1c21">cpl::cast_const</a> which work on all the CPL types. The fast <a class="el" href="namespacecpl.html#a9aeb03a3385c66011c8699ffd001d5db">cpl::cast_clever</a> is the same as <code><a class="el" href="namespacecpl.html#a70b200c580762bcd748c55f80d3f63ee" title="A static cast between reference types.">cpl::cast_static</a></code>. The safe <code><a class="el" href="namespacecpl.html#a9aeb03a3385c66011c8699ffd001d5db" title="A clever cast between reference types.">cpl::cast_clever</a></code> verifies that <code><a class="el" href="namespacecpl.html#a70b200c580762bcd748c55f80d3f63ee" title="A static cast between reference types.">cpl::cast_static</a></code> gives the same results as <code><a class="el" href="namespacecpl.html#a332fd4d2b5d4d5123c3a5c3fb67efddf" title="A dynamic cast between reference types.">cpl::cast_dynamic</a></code>. This will only fail if there are virtual base classes involved, in which case you should use the more costly <code><a class="el" href="namespacecpl.html#a332fd4d2b5d4d5123c3a5c3fb67efddf" title="A dynamic cast between reference types.">cpl::cast_dynamic</a></code>. Other than this, CPL lets you freely shoot yourself in the foot using the casts.</p>
<p>The names are all reversed since the normal names are keywords making them impossible to use as function names.</p>
<h2>Guidelines</h2>
<p>The use of the raw <code>T&amp;</code> should be reserved for function arguments when the function does not store away a reference somewhere that outlives the function invocation. When the argument is optional, <code>T*</code> may be used (this should be very rare).</p>
<p>Otherwise (in data members, static variables, etc.) the CPL data types should be used. Using <code>T*</code> and <code>T&amp;</code> may be needed when interfacing with non-CPL code.</p>
<p>CPL managed data should reside inside some CPL type. This means that it needs to be created using <code>make_uptr</code>, <code>make_uref</code>, <code>make_sptr</code>, <code>make_sref</code> or be held inside a normally-constructed <code>opt</code> or an <code>is</code> object. Having to use the <code>is</code> type instead of a simple <code>T</code> is an unfortunate price we have to pay to allow the safe implementation to track the lifetime of the object and detect dangling pointers to it after it is destroyed. As a consolation it provide the advantage that all objects that have long-lasting pointers to them are clearly marked as such as the code.</p>
<p>It is possible to use <code>unsafe_ptr</code> and <code>unsafe_ref</code> to refer to arbitrary data. This is only safe when the data is <code>static</code>; CPL will not be able to detect invalid pointers to such data if it goes out of scope or is otherwise deleted. Alas, it is not possible to express the "this data is
static" constraint in C++, so it is impossible for CPL to distinguish the safe and unsafe cases.</p>
<h2>Collections</h2>
<p>Unless <a class="el" href="cpl_8hpp.html#a0c728331264de7f1c60fd225a00fd327">CPL_WITHOUT_COLLECTIONS</a> is defined, then CPL will provide the <a class="el" href="classcpl_1_1bitset.html">cpl::bitset</a>, <a class="el" href="classcpl_1_1map.html">cpl::map</a>, <a class="el" href="classcpl_1_1set.html">cpl::set</a>, <a class="el" href="classcpl_1_1string.html">cpl::string</a> and <a class="el" href="classcpl_1_1vector.html">cpl::vector</a> types. These will compile to the standard versions in fast mode and to the (G++ specific) debug versions in safe mode.</p>
<p>Using these types instead of the <code>std</code> types will provide additional checks in safe mode, detecting out-of-bounds and similar errors, while having zero impact on the fast mode. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5a0b6e849e915ae912616e8beb9953bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::experimental::in_place_t <a class="el" href="namespacecpl.html#a5a0b6e849e915ae912616e8beb9953bc">cpl::in_place_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow convenient access to <code>std::experimental::in_place_t</code>. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00355">355</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a361f47273a7617ebea123aa175c65486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecpl.html#a361f47273a7617ebea123aa175c65486">cpl::unsafe_const_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An additional parameter for unsafe const cast operations. </p>
<p>This allows us to use <a class="el" href="test_8cpp.html#ac65fd8adb35b5b64290ed31bc5698d03">MUST_NOT_COMPILE</a> for verifying unsafe constructions are indeed forbidden. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00479">479</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a968cd2eed2b384295813a70b4c835b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecpl.html#a968cd2eed2b384295813a70b4c835b0f">cpl::unsafe_dynamic_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An additional parameter for unsafe dynamic cast operations. </p>
<p>This allows us to use <a class="el" href="test_8cpp.html#ac65fd8adb35b5b64290ed31bc5698d03">MUST_NOT_COMPILE</a> for verifying unsafe constructions are indeed forbidden. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00473">473</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3414592c64c7ef9b526d740c7cf435bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecpl.html#a3414592c64c7ef9b526d740c7cf435bf">cpl::unsafe_raw_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An additional parameter for unsafe raw pointer operations. </p>
<p>This allows us to use <a class="el" href="test_8cpp.html#ac65fd8adb35b5b64290ed31bc5698d03">MUST_NOT_COMPILE</a> for verifying unsafe constructions are indeed forbidden. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00461">461</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9ddc9416cbac9cf7f5f665714489da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecpl.html#ab9ddc9416cbac9cf7f5f665714489da1">cpl::unsafe_static_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An additional parameter for unsafe static cast operations. </p>
<p>This allows us to use <a class="el" href="test_8cpp.html#ac65fd8adb35b5b64290ed31bc5698d03">MUST_NOT_COMPILE</a> for verifying unsafe constructions are indeed forbidden. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00467">467</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9aeb03a3385c66011c8699ffd001d5db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsref.html">sref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between reference types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01307">1307</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38cbc0df9eac079969ed863e7a5c5866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">const sptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between pointer types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01321">1321</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab7fcd2fea50df5adaf3c8210249317bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">const wptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between pointer types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01335">1335</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a811acc150b293d6aa0ba696ab85fa1c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuref.html">uref</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between reference types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01349">1349</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f2f18b2919ce81361036c36f0ac6991"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">uptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between pointer types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01363">1363</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1bdcbbbbba04762582417b022b92d7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classref.html">ref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between reference types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01377">1377</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e3db3c0707b3355715484b6069d9f71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::cast_clever </td>
          <td>(</td>
          <td class="paramtype">const ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A clever cast between pointer types. </p>
<p>In safe mode, this verifies that the raw pointer value did not change, which will always be true unless you use virtual base classes. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01391">1391</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab61ae86127a5b3b4f18c69a60f6a1c21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsref.html">sref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01507">1507</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a225b146ef3c837a9748e43b1c6b0ad20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">const sptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01512">1512</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cbabc449527c16a2632f253df5e09a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">const wptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01517">1517</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8063ecffdb1034d42d2dd071110dbec8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuref.html">uref</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01522">1522</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd556840d0daa32a968229b8dc500619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">uptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01527">1527</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3df17a8a23834d5c757305de6e0be3c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classref.html">ref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01532">1532</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a747fcba4f5ab20f462b81b9223ba731f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::cast_const </td>
          <td>(</td>
          <td class="paramtype">const ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01537">1537</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a332fd4d2b5d4d5123c3a5c3fb67efddf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsref.html">sref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01437">1437</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a799206e33be9e2cb9ea99d65d661914b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const sptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01442">1442</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e18f77c73d40d474a86abcc9ec6b320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const wptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01447">1447</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afec1bb714ed38157e82f5f5dd0632f26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuref.html">uref</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01452">1452</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa64faadd3645eaa26a54955966fe87bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">uptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01457">1457</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa59e660f7aa3b8e1021f27e80f94b20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classref.html">ref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01462">1462</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39e053a3fa5df58e98968757d84e632f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dynamic cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01467">1467</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac642594daa02bd36f81c2da3d6b09c6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* cpl::cast_raw_ptr </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_raw_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a raw pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00482">482</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa5496e4928308f2ce409e12fe33df1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* cpl::cast_raw_ptr </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_static_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a raw pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00487">487</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aee03dd5b8a4973624221d9135833c7f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* cpl::cast_raw_ptr </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_dynamic_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a raw pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00492">492</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7eccb73ec89685c6e8cea1778cea2b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* cpl::cast_raw_ptr </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_const_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a raw pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00497">497</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a081bdf2cd9349c9ff69c3e46109702d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsref.html">sref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01402">1402</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7a4dcef08c1023653704fed971f4c11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">const sptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01407">1407</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cbfe4e8384a8458f95329b13a2d6670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">const wptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01412">1412</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4efd5be5daaf6ce4cecb4cff55a5308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuref.html">uref</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01417">1417</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4ab491d47fc4401b7ff3b7051fd554f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">uptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01422">1422</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c7202df77cf98c87206999239ca984e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classref.html">ref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01427">1427</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8991d28822179e536ab745a93daa48cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::cast_reinterpret </td>
          <td>(</td>
          <td class="paramtype">const ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01432">1432</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b94622c80062ffab3f275fd9f78ae71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cpl::cast_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_raw_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a shared pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00522">522</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a040ae2d0120b81fb1166bcc6846348b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cpl::cast_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_static_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a shared pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00527">527</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a788903c23291104e3697939658db3e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cpl::cast_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_dynamic_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a shared pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00532">532</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c692380f478a93f3cacf6a749cabc63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cpl::cast_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_const_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a shared pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00537">537</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a70b200c580762bcd748c55f80d3f63ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsref.html">sref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01472">1472</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad21269317666734af32412d9dbacb3cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">const sptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01477">1477</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc96be13e230e45db5ce3de83b9da76e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcpl_1_1wptr.html">wptr</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">const wptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01482">1482</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aace6049e216b9adf437158c8fb34a7be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classuref.html">uref</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01487">1487</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c32059b0c16ac165dddcefac63d17f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">uptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01492">1492</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad699e8a81ec43e4ce8c69b3096e653b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classref.html">ref</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between reference types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01497">1497</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5a3a672ff39f9c8a574372dba2c26b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::cast_static </td>
          <td>(</td>
          <td class="paramtype">const ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static cast between pointer types. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01502">1502</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a797c2f74054e26009863e31dce06e924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; cpl::cast_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_raw_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a unique pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00502">502</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32966b9f4abeb6d91bbef1a084ecc516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; cpl::cast_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_static_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a unique pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00507">507</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11ca09643594d6dd94536695f7a3d13c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; cpl::cast_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_dynamic_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a unique pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00512">512</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a544dc4ee100e36788220788b86927c6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; cpl::cast_unique_ptr </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsafe_const_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a unique pointer to a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00517">517</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6093b05e30e21c22341a588f2f3c317d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;T&gt; cpl::cast_weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>into_unsafe_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::weak_ptr&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>from_weak_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cast_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the weak pointer of a <code>ptr</code> of a different type. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00544">544</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03c4ee3440a6b4367b11075c4413718f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sptr.html">sptr</a>&lt;T&gt; cpl::make_sptr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create some value owned by a shared pointer. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01273">1273</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa69747258a545d1281eb66827c56c3dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1sref.html">sref</a>&lt;T&gt; cpl::make_sref </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create some value owned by a shared reference. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01268">1268</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf4fac44bb6dbf5d9bb28c3d17983c86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uptr.html">uptr</a>&lt;T&gt; cpl::make_uptr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create some value owned by a unique pointer. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01283">1283</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c8cb4c0096c46fef78b5f07f15f4008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1uref.html">uref</a>&lt;T&gt; cpl::make_uref </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create some value owned by a unique reference. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01278">1278</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e16040ea171333091ba0a85d5bd0064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ptr.html">ptr</a>&lt;T&gt; cpl::unsafe_ptr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unsafe pointer to raw data. </p>
<p>This is playing with fire. It is OK if the data is static, but there's no way to ask the compiler to ensure that. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01299">1299</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a205c84d0c8d8291953c58fa3a9f7a0df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpl_1_1ref.html">ref</a>&lt;T&gt; cpl::unsafe_ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unsafe reference to raw data. </p>
<p>This is playing with fire. It is OK if the data is static, but there's no way to ask the compiler to ensure that. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l01291">1291</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ad97ed0af4f1706abd58d26e2ccb44fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::experimental::in_place_t cpl::in_place {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow convenient access to <code>std::experimental::in_place</code>. </p>

<p>Definition at line <a class="el" href="cpl_8hpp_source.html#l00358">358</a> of file <a class="el" href="cpl_8hpp_source.html">cpl.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 18 2015 08:15:26 for CPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
